---
title: Codeup和PAT刷题记录——算法初步
tags: [algorithms]
categories: algorithms
date: 2020-05-20 16:45:22
---

记录刷题过程中遇到的问题和技巧。

# 一、技巧总结
## 1.排序
### 1.1 简单选择排序
总共进行n趟操作，每趟选出A[i，n]中最小的元素与A[i]交换。
```c
void selectSort(){
    for(int i=1;i<=n;i++){
        int k=i;
        for(int j=i;j<=n;j++){
            if(A[j]<A[k])
                k=j;
        }
        int temp=A[i];
        A[i]=A[k];
        A[k]=temp;
    }
}
```
### 1.2 直接插入排序
总共进行n-1趟，每趟将A[i]插入A[i-1,1]中合适位置。
```c
void insertSort(){
    for(int i=2;i<=n;i++){
        int temp=A[i];
        for(int j=i;j>1;j--){
            if(temp<A[j])
                A[j]=A[j-1];
        }
        A[j]=temp;
    }
}
```
### 1.3 C++标准模板库中的sort()
由于c语言中的qsort函数涉及很多指针操作，且std中的sort()在实现中规避了经典快速排序中可能出现的导致实际时间复杂度退化到O(n<sup>2</sup>)的极端情况。使用C++头文件需要添加std的命名空间：
```c
#include<stdio.h>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数cmp(非必填，默认递增排序)) //注意序列中的元素一定要有可比性才可以不写cmp函数，否则需指定cmp比较规则，例如结构体。

//基本数据类型数组的排序 int double ...
int A[6]={};
bool cmp(int a, int b) {return a>b;}
sort(A,A+4,cmp); //将A[0]-A[3]从大到小排序

//结构体的排序
struct Node{
    int x,y;
    char name[10];
}ssd[10];
bool cmp(node a, node b){    //若x不等，按x从大到小排序，否则按y从小到大排序。
    if(a.x!=b.x) return a.x>b.x;
    else return a.y < b.y
}
strcmp(a.name,b.name)<0; //表示a.name字典序小于b.name的字典序。<font color=Crmison>注意！strcmp返回值不一定是-1或+1,故==-1写法错误。</font>
sort(ssd,ssd+3,cmp);

//容器的排序
vector<int> vi;
vi.push_back(3);
....//初始化
bool cmp(int a, int b) {return a>b;}  //vector中类型为int型
sort(vi.begin,vi.end,cmp);

string str[3]={"bbbb","cc","aaa"};
str[0]>str[1];  //true,c++中string之间可直接比较大小。
bool cmp(string str1,string str2){return str1.length < str2.length;} //按字符串长度递增排序
sort(str,str+3);
sort(str,str+3,cmp);
```
### 1.4 排名的实现
分数不同排名不同，分数相同排名相同但占用一个排位：
先排序：
思路1：将排名这一项添加到结构体中进行记录，若当前个体分数等于上一个个体则排名等于上一个个体排名，否则当前个体排名等于数组下标+1。
思路2：不记录进结构体，直接输出排名。

## 2. 散列
### 2.1 散列的定义
有些算法题消耗时间很长，需要利用空间换时间的策略，如将输入的数字作为数组下标来统计这个数出现的次数，而输入的数不一定为整数，且有可能出现冲突，即输入多个相同的数，这时就需要用到散列的策略。
定义：将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素。可使用C++标准模板库中的map或reordered_mp直接使用整数hash的功能。散列常应用在查找某个字符串或数字是否出现或出现的次数。

### 2.2 整数散列
其中直接定址法、平方取中法、除留余数法为散列方法；线性探查法(开放定址法)、平方探查法(开放定址法)、链地址法(拉链法)为解决冲突的方法。
#### 2.2.1 直接定址法
H(key)=key
H(key)=a*key+b
#### 2.2.2 平方取中法
取key的平方的中间若干位作为hash值，很少用。
#### 2.2.3 除留余数法
为最常用方法。
H(key)=key%mod
该方法可将一个较大的数变为可行的数组下标。
表长TSize必须不小于mod，否则越界，一般取TSize=mod，且mod取素数可有效避免冲突。
#### 2.2.4 线性探查法
若H(key)位置被占用，则检查H(key)+1，H(key)+2,...，直到找到一个没被占用的位置，若超过了表长则回到表的首位继续循环查找。此方法容易出现扎堆现象，即表中连续若干个位置都被使用，一定程度上会降低效率。
#### 2.2.5 平方探查法
- 该方法可避免扎堆现象。
- 若H(key)位置被占用，则检查H(key)+1<sup>2</sup>，H(key)-1<sup>2</sup>,H(key)+2<sup>2</sup>,H(key)-2<sup>2</sup>...，直到找到一个没被占用的位置，也可只进行正向平方探查。
- 若超过了表长则计算(H(key)+k<sup>2</sup>)%mod。
- 若H(key)-k<sup>2</sup><0,则计算((H(key)-k<sup>2</sup>)%TSize+TSize)%TSize;相当于将H(key)-k<sup>2</sup>不断加上TSize直到出现第一个非负数。
- 可证明，若k在[0，TSize)范围内都无法找到位置，那么当k>=TSize时也一定无法找到位置。

#### 2.2.6 链地址法（拉链法）
设定一个数组链表，Link[0]-Link[mod-1],用Link[h]将所有H(key)=h的key链接起来。
<font color=Crmison>注意！以上方法一般都无需自己实现，除非必须模拟这些算法或提升效率，否则都可以直接使用标准模板库中的map函数来直接使用hash功能，C++11以后可以用unordered_map，速度更快。</font>

### 2.3 字符串hash初步
利用其它进制转换为10进制的策略，仅限字符串长度不是很长的情况。
- 若字符串均由大写字母构成：将26个大写字母视为26进制，转换为10进制。
- 若出现了小写字母，则将A-Z作为0—25,将a-z作为26-51(例如a-'a'+26)，共52进制，转换为10进制。
- 若出现了数字，则可按照小写字母的处理方法增大进制数至62。
- 若能保证字符串末尾是数字则可将末尾的数字直接拼接上去。
- <font color=Crmison>ASCII码的hash值可用 字符-'\0' 计算，因为'\0'的ASCII码值为0。</font>

## 3. 递归
    

# 二、经典题目
## 2.1 问题 B: 分组统计
**题目描述**
先输入一组数，然后输入其分组，按照分组统计出现次数并输出，参见样例。
**输入**
输入第一行表示样例数m，对于每个样例，第一行为数的个数n，接下来两行分别有n个数，第一行有n个数，第二行的n个数分别对应上一行每个数的分组，n不超过100。
**输出**
输出m行，格式参见样例，按从小到大排。
**样例输入** 
1
7
3 2 3 8 8 2 3
1 2 3 2 1 3 1
**样例输出**
1={2=0,3=2,8=1}
2={2=1,3=0,8=1}
3={2=1,3=1,8=0}
**思路**
- 利用一个二维矩阵A[i][j]记录数字j在组别i中出现的次数
- flagS[j]和flagG[i]分别记录数字j和组别i是否出现，这里容易出错 
- 找出最大组别编号和最大数字，若组号i和数字j均存在，则输出result[i][j]
- <font color=Crmison>易错点:组号i小于n，但样例数大小j范围未知，二维数组的第二维应初始化大一些，否则容易错误50%</font>
```c
int main(){
	
	int m,n;
	while(scanf("%d",&m)!=EOF){
		while(m--){
			scanf("%d",&n);	
			//在循环内部定义数组就无须初始化为0了 
			int sample[110]={},flagS[2010]={},group[110]={},flagG[110]={};
			
			int maxs=0,maxg=0; //找出最大样例和最大组别，方便输出。 
			for(int i=0;i<n;i++){
				scanf("%d",sample+i);
				if(sample[i]>maxs) maxs=sample[i];
				flagS[sample[i]]=1; 
			} 
			
			int result[110][2010]={};
				
			for(int i=0;i<n;i++){
				scanf("%d",group+i);
				if(group[i]>maxg) maxg=group[i];
				flagG[group[i]]=1;
				//记录统计结果 
				result[group[i]][sample[i]]++; 
			} 
			
			//输出统计结果 
			for(int i=0;i<=maxg;i++){
				if(flagG[i]==1){
					printf("%d={",i);
					for(int j=0;j<=maxs;j++){
						if(flagS[j]==1){
							printf("%d=%d",j,result[i][j]);
							if(j<maxs) printf(",");
						}
					}
					printf("}\n");	
				} 		
			}	
		}	
	} 
	return 0;
} 
```
