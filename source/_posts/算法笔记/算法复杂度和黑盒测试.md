---
title: 算法复杂度和黑盒测试
tags: [algorithms,C,C++]
categories: algorithms
date: 2020-04-23 23:29:52
---

## 引言
了解算法复杂度很重要，我们在编写算法时常常要注意算法复杂度以避免出现程序运行超时的结果，此外，了解常用OJ的黑盒测试方法也有助于编写正确高效的算法。本篇简单介绍了三种算法复杂度和黑盒测试的代码写法，并简单罗列了OJ在判定时出现的一些结果，以便找到出错原因。

# 一、算法复杂度
## 1. 时间复杂度
时间复杂度是算法执行基本运算(如加减乘除)的次数所处的等级，是评判算法时间效率的有效标准，较高的时间复杂度会让评测系统返回“运行超时”，<font color=Crmison>对一般的OJ系统来说，一秒能承受的运算次数大概是10<sup>7</sup>至10<sup>8</sup>。</font>

> 1. 讲时间复杂度是不带系数的，称为时间复杂度常数，例如基本运算次数为cn,cn<sup>2</sup>，则时间复杂度分别为O(n)，O(n<sup>2</sup>)。
2. 高等级的幂次会覆盖低等级的幂次，因此O(3n<sup>2</sup>+n+2)=O(n<sup>2</sup>)。
3. 当某些算法实现较为复杂时，其常数会比较大，这时即使时间复杂度相同其性能也会有较大差距。
4. 不同级别时间复杂度比较：O(1)<O(logn)<O(n)<O(n<sup>2</sup>)。

## 2. 空间复杂度
空间复杂度和时间复杂度的写法相同，表示算法需要消耗的最大数据空间。一般来说空间都是足够使用的，只要不开好几个10<sup>7</sup>以上的数组，<font color=Crmison>故一般会使用以空间换时间的算法策略。</font>

## 3. 编码复杂度
编码复杂度是一个定性的概念，没有一个量化标准，就是指代码的冗长程度。如果使用了冗长的算法思想则编码复杂度就会很大。

# 二、黑盒测试
OJ后台会准备若干组数据(一般是放在一个文件里)让程序运行，并将运行结果在字符串意义上进行比较，若完全相同，则称通过了本题的黑盒测试，否则返回不同判定结果，根据黑盒测试对每组数据单独测试还是一次性全部测试，分为单点和多点测试。

## 1. 单点测试
PAT采取的是单点测试，它会对每组数据都给出相应的测评结果，并且每组数据都有得分值，题目总得分等于通过数据得分值之和。所以它仅要求编写的程序能一次运行一组数据，采用普通写法。

## 2. 多点测试
大部分OJ如Codeup等都是采用多点测试，它要求编写的程序能够一次性运行所有的数据，并要求所有输出结果都必须完全正确才算通过测试，故需要用到循环结构。多点测试能够考验算法编写的严谨性。题目一般会有3种输入格式，需要采取不同的输入方式。

> 三种输入类型

```c
//循环输入直到文件末尾
while(scanf("%d",&n)!=EOF){
    ...//scanf返回值为成功读入的参数个数，当读取文件到达末尾时才会读取失败，此时返回-1，C语言中用EOF(End Of File)代替-1。
    //在运行框输入数据时并不会触发EOF，需要手动输入<Ctrl+Z>键，再按<Enter>键触发。
}
while(scanf("%s",str)!=EOF){...}
while(gets(str)!=NULL){...}

//输入直到满足某个条件时退出
while(scanf("%d%d",&a,&b), a||b){
    ...//当a和b中有一个不为零时就进行循环。注意！输入多少数据(&a和&b)，判零条件就有几个(a||b)，否则输入输出的格式会出错。
}

//输入题目指定组数的数据
while(T--){...}
```

另外要<font color=Crmison>注意！多点测试中每一次循环都要重置一下变量和数组(memset函数或fill函数)，否则在下一组数据来临之前变量和数组的状态就不是初始状态了。</font>

# 三、OJ常见评测结果

## 1. 答案正确(Accepted, AC)
若为单点测试，则每通过一组数据就会返回一个Accepted,若是多点测试，那么只有当通过了所有数据时，才会返回Accepted。

## 2. 编译错误(Compile Error, CE)
出现这种情况有可能是选错了语言。

## 3. 答案错误(Wrong Answer, WA)
代码逻辑问题或输出的内容有误。

## 4. 运行超时(Time Limit Excees, TLE)
一般来说，导致该结果是由于算法的时间复杂度导致的，也可能是某组数据使得代码某处死循环了。

## 5. 运行错误(Runtime Error, RE)
段错误(非法访问内存，如数组越界、指针乱指)、浮点错误(例如除数为0、模数为0)、递归爆栈(一般由于递归层数过深)。

## 6. 内存超限(Memory Limit Exceeded, MLE)
如果程序使用太多空间，例如数组太大可能会导致此结果。

## 7. 格式错误(Presentation Error, PE)
多输出了空格或换行。

## 8. 输出超限(Output Limit Exceeded, OLE)
输出了过量的内容，如大量调试信息或者特殊数据导致的死循环。